<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <title>agda2lambox</title>
<style>
body {
  font-family: 'JetBrains Mono', monospace;
  height: 100vh;
  margin: 0;
  padding: 1rem;
  box-sizing: border-box;
  display: grid;
  gap: 1em;
  grid-template-rows: auto 1fr;
}
h1 {
  margin: 0 0 .5rem;
  font-size: 1.4rem;
  text-transform: uppercase;
}
button, select, input[type="text"],
input[type="file"]::file-selector-button {
  padding: .2rem .5rem
}
fieldset {
  margin: 0;
  padding: 0;
  border: none;
  + fieldset {margin-top: .5rem;}
}
pre {
  overflow-y: scroll;
  white-space: pre-wrap;
  border-radius: .3rem;
  background: #eee;
  margin: 0;
  padding: 1rem;
}
.error { color: #900 }
</style>
  </head>
  <body>
<header>
  <h1>agda2lambox</h1>
  <fieldset>
    <button id="run" disabled>Run</button>
    <button id="reload" disabled>Reload</button>
    <button id="clear">Clear</button>
    <input type="file" id="file" />
  </fieldset>
  <fieldset>
    <label for="useinput">Input</label>
    <input type="checkbox" id="useinput">
    <input type="text" id="input">
    <select id="encoder">
      <option value="bool">Bool</option>
    </select>
  </fieldset>
  <fieldset>
    Output
    <select id="decoder">
      <option value="nat">Nat</option>
      <option value="bool">Bool</option>
      <option value="listnat">List Nat</option>
      <option value="listbool">List Bool</option>
      <option value="string">String (List Nat)</option>
    </select>
  </fieldset>
  <fieldset>
    Function
    <select id="program"></select>
  </fieldset>
</header>
<pre><code id="output"></code></pre>
<script type="module">
const on = (t, e, f) => t.addEventListener(e, f)

run.disabled = reload.disabled = true
input.disabled = encoder.disabled = !useinput.checked
on(useinput, "change", () => input.disabled = encoder.disabled = !useinput.checked)

let wasm    = null
let mem_ptr = null
let mem     = null
let exposed = null

on(file,   "change", load)
on(reload, "click",  load)
on(run,    "click",  exec)
on(clear,  "click", () => output.innerHTML = "")

async function load() {
  if (file.files.length == 0) return

  let [blob] = file.files

  log(`Loading ${blob.name}...`)

  try {

    wasm =
      await blob.arrayBuffer()
        .then(buf => {
          log("Compiling...")
          return WebAssembly.compile(buf)
        })
        .then(mod => new WebAssembly.Instance(mod))

    mem_ptr = wasm.exports.mem_ptr
    mem     = wasm.exports.memory.buffer

    log(`Compiled!`)

    exposed =
      Object.keys(wasm.exports)
        .filter(key => typeof wasm.exports[key] == 'function')

    // update available function list
    program.textContent = ''
    exposed.forEach(fn => {
      let opt = document.createElement('option')
      opt.value = fn
      // show arity
      opt.textContent = `${fn} (${wasm.exports[fn].length})`
      program.appendChild(opt)
    })

    run.disabled = false
    reload.disabled = false

  } catch (e) {
    log(`Failed to compile: ${e}`, true)
  }
}

async function exec() {
  log(`Running ${program.value}`)

  let fn = wasm.exports[program.value]

  try {
    if (useinput.checked) {
      let val = eval(input.value)
      let enc = encoders[encoder.value]
      let res = enc(val)
      fn(res)
    }
    else {
      fn()
    }

    let res = wasm.exports.result.value
    let dec = decoders[decoder.value]

    log(`Result: ${pretty(dec(res))}`)
  } catch (e) {
    log(`Failed to run: ${e}`, true)
    if (wasm.exports.out_of_mem.value) {
      log(`Wasm instance may have run out of memory...`, true)
    }
    throw e
  }
}

function log(str, err = false) { // ugly logging
  if (err)
    output.innerHTML += `<span class="error">${str}</span>\n`
  else output.innerHTML += `${str}\n`
}

function pretty(v) {
  if (typeof v == "string")
    return `"${v}"`
  else if (Array.isArray(v))
    return `[${v.map(pretty)}]`
  else return v.toString()
}

load()

// custom decoders -------------------------

/* "CertiCoq-Wasmâ€™s representation of
    a ðœ†ANF constructor value ð¶(ð‘£s) is based on the one used by
    CertiCoqâ€™s C backend [ 41, Â§4.1], which in turn is based on the
    one used by the OCaml compiler. For efficiency, we represent
    nullary constructor values as unboxed i32 values (using 31
    bits), while non-nullary constructor values are boxed: they
    are represented by an address starting from which linear
    memory contains the code of the constructor, followed by
    the arguments. The least significant bit of the i32 is used to
    distinguish the two."
*/

const bool  = value => (value >> 1) == 1

const nat = value => {
  let acc = 0
  while (!(value & 1)) {
    value = mem[value + 4 >> 2]
    acc++
  }
  return acc
}

const list = decoder => value => {
  let acc = []
  while (!(value & 1)) {
    let head = mem[value + 4 >> 2]
    value    = mem[value + 8 >> 2]
    acc.push(decoder(head))
  }
  return acc
}

const string = value => {
  let chars = list(nat)(value)
  return String.fromCharCode(...chars)
}

const decoders =
  { nat
  , bool
  , listnat: list(nat)
  , listbool: list(bool)
  , string
  }

// custom encoders -------------------------------

/*
  NOTE: for now, encoders happily write in the memory buffer,
        and update the mem_ptr.
  TODO: proper memory mgmt, where the linear memory is expanded if
        we run out of memory.

- All encoders take a JS value as input,
- They write it in memory starting from mem_ptr.
- They update mem_ptr to point to the next available location.
- They return a value to be given to programs.
    (Likely to be the a pointer, but not necessarily).
*/
const encoders =
  { bool: v => v << 1 | 1
  }
</script>
  </body>
</html>
