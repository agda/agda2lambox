<pre><code>LamBox.Empty:
  mutual inductive(s):
    Empty
    type variables:  []
      constructors:

Scheme.Bad:
  type alias:
    type variables: []
    type: ùïã

Agda.Builtin.List.List:
  mutual inductive(s):
    List
    type variables:  [a, A]
      constructors:
        ’ñ5b’ñ’ñ5d’ñ (0 arg(s))
        ’ñ_’ñcons_ (2 arg(s))
          x : @1
          xs : Agda.Builtin.List.List{0} ‚ñ° @1

Scheme.Œ£:
  mutual inductive(s):
    Œ£
    type variables:  [A, B]
      constructors:
        ’ñ_’ñ2c’ñ_ (2 arg(s))
          fst : @0
          snd : ‚ñ°

Scheme.Œ£’ñsubsyntax:
  type alias:
    type variables: [A, B]
    type: Scheme.Œ£{0} @0 ‚ñ°

Scheme.Vec:
  type alias:
    type variables: [A, _]
    type: Scheme.Œ£’ñsubsyntax (Agda.Builtin.List.List{0} ‚ñ° @0) ‚ñ°

Scheme.ListAlias’ñ27’ñ:
  type alias:
    type variables: [_]
    type: Agda.Builtin.List.List{0} ‚ñ° @0

Scheme.ListAlias:
  type alias:
    type variables: [_]
    type: Agda.Builtin.List.List{0} ‚ñ° @0

Scheme.Arrow:
  type alias:
    type variables: [A, B]
    type: @0 ‚Üí @1

Scheme.Œ£.snd:
  constant declaration:
    type variables: []
    type: ‚ñ°
    body: ‚ñ°

Scheme.Œ£.fst:
  constant declaration:
    type variables: [A, B]
    type: Scheme.Œ£{0} @0 ‚ñ° ‚Üí @0
    body: Œª _ ‚Üí case&lt;Scheme.Œ£{0},0&gt; @0 of Œª&lt;[_, _]&gt; @1

Scheme.Eq:
  constant declaration:
    type variables: []
    type: ‚ñ°
    body: ‚ñ°

Agda.Builtin.Nat.Nat:
  mutual inductive(s):
    Nat
    type variables:  []
      constructors:
        zero (0 arg(s))
        suc (1 arg(s))
          n : Agda.Builtin.Nat.Nat{0}

Scheme.length:
  constant declaration:
    type variables: [A]
    type: ‚ñ° ‚Üí Agda.Builtin.List.List{0} ‚ñ° @0 ‚Üí Agda.Builtin.Nat.Nat{0}
    body: Œºrec [0] :=
            0: Œª _ _ ‚Üí
                 case&lt;Agda.Builtin.List.List{0},0&gt; @0 of
                   Œª&lt;[]&gt; Agda.Builtin.Nat.Nat{0}{0}
                   Œª&lt;[_, _]&gt; Agda.Builtin.Nat.Nat{0}{1} (@4 ‚ñ° @0)</code></pre>
