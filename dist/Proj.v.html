<pre class="coq"><code>From Stdlib           Require Import List.
From MetaRocq.Common  Require Import BasicAst Kernames Universes.
From MetaRocq.Utils   Require Import bytestring.
From MetaRocq.Erasure Require Import EAst.
From Agda2Lambox     Require Import CheckWF Eval.
Import ListNotations.

Definition env : global_declarations :=
  [((MPfile [&quot;Proj&quot;%bs; &quot;Pair&quot;%bs], &quot;fst&quot;%bs),
    ConstantDecl
      {| cst_body :=
           Some
             (tLambda
                nAnon
                (tCase
                   ({| inductive_mind := (MPfile [&quot;Proj&quot;%bs], &quot;Pair&quot;%bs);
                       inductive_ind := 0 |},
                    0)
                   (tRel 0) [([nAnon; nAnon], tRel 1)])) |});
   ((MPfile [&quot;Proj&quot;%bs], &quot;second&quot;%bs),
    ConstantDecl
      {| cst_body :=
           Some
             (tApp
                (tConst (MPfile [&quot;Proj&quot;%bs; &quot;Pair&quot;%bs], &quot;snd&quot;%bs))
                (tConst (MPfile [&quot;Proj&quot;%bs], &quot;pair&quot;%bs))) |});
   ((MPfile [&quot;Proj&quot;%bs], &quot;pair&quot;%bs),
    ConstantDecl
      {| cst_body :=
           Some
             (tApp
                (tApp
                   (tConstruct
                      {| inductive_mind := (MPfile [&quot;Proj&quot;%bs], &quot;Pair&quot;%bs);
                         inductive_ind := 0 |}
                      0 [])
                   (tConstruct
                      {| inductive_mind := (MPfile [&quot;Proj&quot;%bs], &quot;Bool&quot;%bs);
                         inductive_ind := 0 |}
                      1 []))
                (tConstruct
                   {| inductive_mind := (MPfile [&quot;Proj&quot;%bs], &quot;Bool&quot;%bs);
                      inductive_ind := 0 |}
                   0 [])) |});
   ((MPfile [&quot;Proj&quot;%bs], &quot;Bool&quot;%bs),
    InductiveDecl
      {| ind_finite := Finite; ind_npars := 0;
         ind_bodies :=
           [{| ind_name := &quot;Bool&quot;%bs; ind_propositional := false;
               ind_kelim := IntoAny;
               ind_ctors :=
                 [{| cstr_name := &quot;r#false&quot;%bs; cstr_nargs := 0 |};
                  {| cstr_name := &quot;r#true&quot;%bs; cstr_nargs := 0 |}];
               ind_projs := [] |}] |});
   ((MPfile [&quot;Proj&quot;%bs; &quot;Pair&quot;%bs], &quot;snd&quot;%bs),
    ConstantDecl
      {| cst_body :=
           Some
             (tLambda
                nAnon
                (tCase
                   ({| inductive_mind := (MPfile [&quot;Proj&quot;%bs], &quot;Pair&quot;%bs);
                       inductive_ind := 0 |},
                    0)
                   (tRel 0) [([nAnon; nAnon], tRel 0)])) |});
   ((MPfile [&quot;Proj&quot;%bs], &quot;Pair&quot;%bs),
    InductiveDecl
      {| ind_finite := Finite; ind_npars := 0;
         ind_bodies :=
           [{| ind_name := &quot;Pair&quot;%bs; ind_propositional := false;
               ind_kelim := IntoAny;
               ind_ctors :=
                 [{| cstr_name := &quot;\1366_\1366\&amp;2c\1366_&quot;%bs; cstr_nargs := 2 |}];
               ind_projs := [] |}] |});
   ((MPfile [&quot;LamBox&quot;%bs], &quot;Empty&quot;%bs),
    InductiveDecl
      {| ind_finite := Finite; ind_npars := 0;
         ind_bodies :=
           [{| ind_name := &quot;Empty&quot;%bs; ind_propositional := false;
               ind_kelim := IntoAny; ind_ctors := []; ind_projs := [] |}] |})].

Compute @check_wf_glob eflags env.

Definition prog1 : program :=
  (env, tConst (MPfile [&quot;Proj&quot;%bs], &quot;second&quot;%bs)).

Compute eval_program prog1.</code></pre>
