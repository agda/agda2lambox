<pre class="coq"><code>From Coq             Require Import List.
From MetaCoq.Common  Require Import BasicAst Kernames Universes.
From MetaCoq.Utils   Require Import bytestring.
From MetaCoq.Erasure Require Import EAst ExAst.
From Agda2Lambox     Require Import CheckWF Eval.
Import ListNotations.

Definition env : global_env :=
  [(((MPfile [&quot;Test&quot;%bs], &quot;not&quot;%bs), true),
    ConstantDecl
      {| cst_body :=
           Some
             (tLambda
                nAnon
                (tCase
                   ({| inductive_mind := (MPfile [&quot;Test&quot;%bs], &quot;Bool&quot;%bs);
                       inductive_ind := 0 |},
                    0)
                   (tRel 0)
                   [([],
                     tConstruct
                       {| inductive_mind := (MPfile [&quot;Test&quot;%bs], &quot;Bool&quot;%bs);
                          inductive_ind := 0 |}
                       1 []);
                    ([],
                     tConstruct
                       {| inductive_mind := (MPfile [&quot;Test&quot;%bs], &quot;Bool&quot;%bs);
                          inductive_ind := 0 |}
                       0 [])]));
         cst_type :=
           ([],
            TArr
              (TInd
                 {| inductive_mind := (MPfile [&quot;Test&quot;%bs], &quot;Bool&quot;%bs);
                    inductive_ind := 0 |})
              (TInd
                 {| inductive_mind := (MPfile [&quot;Test&quot;%bs], &quot;Bool&quot;%bs);
                    inductive_ind := 0 |})) |});
   (((MPfile [&quot;Test&quot;%bs], &quot;not\1366\&amp;27\1366&quot;%bs), true),
    ConstantDecl
      {| cst_body :=
           Some
             (tLambda
                nAnon
                (tCase
                   ({| inductive_mind := (MPfile [&quot;Test&quot;%bs], &quot;Bool&quot;%bs);
                       inductive_ind := 0 |},
                    0)
                   (tRel 0)
                   [([],
                     tConstruct
                       {| inductive_mind := (MPfile [&quot;Test&quot;%bs], &quot;Bool&quot;%bs);
                          inductive_ind := 0 |}
                       1 []);
                    ([],
                     tConstruct
                       {| inductive_mind := (MPfile [&quot;Test&quot;%bs], &quot;Bool&quot;%bs);
                          inductive_ind := 0 |}
                       0 [])]));
         cst_type :=
           ([],
            TArr
              (TInd
                 {| inductive_mind := (MPfile [&quot;Test&quot;%bs], &quot;Bool&quot;%bs);
                    inductive_ind := 0 |})
              (TInd
                 {| inductive_mind := (MPfile [&quot;Test&quot;%bs], &quot;Bool&quot;%bs);
                    inductive_ind := 0 |})) |});
   (((MPfile [&quot;Test&quot;%bs], &quot;Bool&quot;%bs), true),
    InductiveDecl
      {| ind_finite := Finite; ind_npars := 0;
         ind_bodies :=
           [{| ind_name := &quot;Bool&quot;%bs; ind_propositional := false;
               ind_kelim := IntoAny;
               ind_ctors := [((&quot;r#true&quot;%bs, []), 0); ((&quot;r#false&quot;%bs, []), 0)];
               ind_projs := []; ind_type_vars := [] |}] |});
   (((MPfile [&quot;Test&quot;%bs], &quot;fromMaybe&quot;%bs), true),
    ConstantDecl
      {| cst_body :=
           Some
             (tLambda
                nAnon
                (tLambda
                   nAnon
                   (tApp
                      (tApp
                         (tLambda
                            nAnon
                            (tLambda
                               nAnon
                               (tLambda
                                  nAnon
                                  (tCase
                                     ({| inductive_mind :=
                                           (MPfile [&quot;Test&quot;%bs; &quot;\1366_&quot;%bs], &quot;Maybe&quot;%bs);
                                         inductive_ind := 0 |},
                                      0)
                                     (tRel 0) [([], tRel 1); ([nAnon], tRel 0)]))))
                         (tRel 1))
                      (tRel 0))));
         cst_type :=
           ([nNamed &quot;a&quot;%bs],
            TArr
              TBox
              (TArr
                 (TVar 0)
                 (TArr
                    (TApp
                       (TInd
                          {| inductive_mind := (MPfile [&quot;Test&quot;%bs; &quot;\1366_&quot;%bs], &quot;Maybe&quot;%bs);
                             inductive_ind := 0 |})
                       (TVar 0))
                    (TVar 0)))) |});
   (((MPfile [&quot;Test&quot;%bs; &quot;\1366_&quot;%bs], &quot;Maybe&quot;%bs), true),
    InductiveDecl
      {| ind_finite := Finite; ind_npars := 0;
         ind_bodies :=
           [{| ind_name := &quot;Maybe&quot;%bs; ind_propositional := false;
               ind_kelim := IntoAny;
               ind_ctors :=
                 [((&quot;nothing&quot;%bs, []), 0); ((&quot;just&quot;%bs, [(nAnon, TVar 0)]), 1)];
               ind_projs := [];
               ind_type_vars :=
                 [{| tvar_name := nNamed &quot;a&quot;%bs; tvar_is_logical := false;
                     tvar_is_arity := true; tvar_is_sort := true |}] |}] |});
   (((MPfile [&quot;LamBox&quot;%bs], &quot;Empty&quot;%bs), true),
    InductiveDecl
      {| ind_finite := Finite; ind_npars := 0;
         ind_bodies :=
           [{| ind_name := &quot;Empty&quot;%bs; ind_propositional := false;
               ind_kelim := IntoAny; ind_ctors := []; ind_projs := [];
               ind_type_vars := [] |}] |})].</code></pre>
